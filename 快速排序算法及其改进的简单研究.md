# 快速排序算法及其改进的简单研究

[TOC]

## 简介

**快速排序**（Quicksort），又称**分区交换排序**（partition-exchange sort），是一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要$O(n\log(n))$次比较。在最坏状况下则需要$O(n^2)$次比较，但这种状况并不常见。事实上，快速排序$\Theta(n\log(n))$通常明显比其他算法更快，因为它的内部循环可以在大部分的架构上很有效率地达成。

**内部循环算法**（In-Place Algorithm）是指一种在算法执行过程中不需要额外的辅助数据结构来存储数据的算法。内部循环算法通常对内存的使用效率要求较高，因为它们需要在原始数据的内存空间中进行操作，而不是创建额外的数据结构来存储中间结果。这有助于减少内存占用并提高算法的性能。

## 方法介绍

快速排序使用**分治法**（Divide and conquer）策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。

步骤为：

1. 挑选基准值：从数列中挑出一个元素，称为基准。
2. 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成。
3. 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。



### 朴素快速排序

**朴素快速排序**算法选取一个**固定元素**作为基准值，一般选取首元素、尾元素或中间元素，为了方便测试最坏情况，这里选择实现以首元素为基准值的朴素快速排序

```c++
#include <iostream>
const int maxn = 1e8;
int st[maxn], t = 0;
extern "C"
{
    void swap(int &a, int &b)
    {
        int t = a;
        a = b;
        b = t;
    }

    std::pair<int, int> partition(int q[], int l, int r)
    {
        int i = l - 1, j = r + 1, x = q[l];
        while (i < j)
        {
            do
                i++;
            while (q[i] < x);
            do
                j--;
            while (q[j] > x);
            if (i < j)
            {
                swap(q[i], q[j]);
            }
        }
        return std::make_pair(j, j + 1);
    }

    void sort(int q[], int l, int r)
    {
        if (l < r)
        {
            std::pair<int, int> pa = partition(q, l, r);
            int j = pa.first, k = pa.second;
            if (j > l)
            {
                st[t++] = l;
                st[t++] = j;
            }
            if (k < r)
            {
                st[t++] = k;
                st[t++] = r;
            }
            while (t != 0)
            {
                int sr = st[--t];
                int sl = st[--t];
                pa = partition(q, sl, sr);
                j = pa.first, k = pa.second;
                if (j > sl)
                {
                    st[t++] = sl;
                    st[t++] = j;
                }
                if (k < sr)
                {
                    st[t++] = k;
                    st[t++] = sr;
                }
            }
        }
    }
}
```



### 随机快速排序

**随机快速排序**是对朴素快速排序的改进，不再选取序列中的固定位置值作为基准，而**随机选取**待排序列中任意一个数作为基准值

```c++
    unsigned int generateSeedFromTimestamp()
    {
        auto now = std::chrono::system_clock::now();
        auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch());

        return static_cast<unsigned int>(timestamp.count());
    }

    std::pair<int, int> partition(int q[], int l, int r)
    {
        unsigned int seed = generateSeedFromTimestamp();
        std::mt19937 engine(seed);
        int i = l - 1, j = r + 1, x = q[l + engine() % (r - l + 1)];
        while (i < j)
        {
            do
                i++;
            while (q[i] < x);
            do
                j--;
            while (q[j] > x);
            if (i < j)
            {
                swap(q[i], q[j])
            }
        }
        return std::make_pair(j, j + 1);
    }
```

### 三路快速排序

**三路快速排序**（3-way Radix Quicksort）是快速排序和基数排序的混合。它的算法思想基于荷兰国旗问题的解法。荷兰国旗问题是Edsger Dijkstra提出的一个计算问题。 荷兰国旗由三种颜色组成：红色、白色和蓝色。给定这三种颜色的球随机排列成一条线，任务是排列它们，使所有相同颜色的球都在一起，并且它们的集体颜色组按正确的顺序排列。

与原始的快速排序不同，三路快速排序在随机选取分界点 m 后，将待排数列划分为三个部分：小于 m、等于 m 以及大于 m。这样做即实现了将与分界元素相等的元素聚集在分界元素周围这一效果。三路快速排序在处理含有多个重复值的数组时，效率远高于原始快速排序。其最佳时间复杂度为$O(n)$



```c++
    std::pair<int, int> partition(int q[], int l, int r)
    {
        unsigned int seed = generateSeedFromTimestamp();
        std::mt19937 engine(seed);
        int i = l, j = l, k = r, x = q[l + engine() % (r - l + 1)];
        while (i <= k)
        {
            if (q[i] < x)
                swap(q[i++], q[j++]);
            else if (q[i] > x)
                swap(q[i], q[k--]);
            else
                ++i;
        }
        return std::make_pair(j - 1, k + 1);
    }
```

在三路排序的基础上，还实现了插入排序，进一步优化在较短有序子序列上的排序

```c++
void insertSort(int q[], int l, int r)
    {
        for (int i = l + 1; i <= r; i++)
        {
            int j = i;
            while (j > l)
            {
                if (q[j] < q[j - 1])
                {
                    swap(q[j], q[j - 1]);
                    j--;
                }
                else
                {
                    break;
                }
            }
        }
    }
```



## 实验

### 实验设置

我们使用C++编写排序算法，然后使用python对排序算法进行调用，通过记录不同类型数据集的不同长度下排序所花费的时间对算法进行性能评价。

为了使实验结果与理论计算结果尽可能接近，需要最大限度保证各组实验变量的一致性，这里选择数组的长度则是一个很重要的因素，因为计算机问题和数学问题通常并不等价，排序算法不是计算密集型问题，而是IO密集型问题，而IO密集型问题通常与cache命中率息息相关，通过计算可知每个int类型占4 B，而L3缓存容量为20 MB，20 MB/4 B  =  5,242,880<$10^7$，所以为了全面评判算法的性能，这里选取序列长度范围为[$10^5$,$10^9$]，对该范围进行等比采样共41个点，每个数组长度跑10次取平均值。

且因为cache空间不一定能被程序独占，对于小于$10^7$序列排序时间的反复震荡是正常现象，所以分析时只考虑大致趋势即可，而对于大于$10^7$序列排序时间的变化都是值得关注和思考的问题。

所使用的环境如下:

| CPU      | i5-12490F              |
| -------- | ---------------------- |
| 基准速率 | 3.00 GHz               |
| L3 缓存  | 20.0 MB                |
| 内存     | 32 GB                  |
| 系统     | windows 11 专业版 22H2 |



#### 数据集
+ 随机分布无序序列，由`numpy.random.randint`生成的序列，范围为$[0,2^{31}-1]$。

+ 递增有序序列，由`data = np.arange`生成的序列，范围为$[0,length]$。
+ 正态分布无序序列，平均值设置为$\frac{length}{2}$，标准差设置为$\frac{length}{6}$，且限制值在$[0,length]$中。



#### 基准

+ **朴素快排**，将朴素快排的c++代码编译成静态库进行调用。
+ **随机快排**，将随机快排的c++代码编译成静态库进行调用。
+ **三路快排**+插入排序，将三路快排的c++代码编译成静态库进行调用。
+ **numpy库排序**，直接调用`numpy.sort()`

### 性能比较

#### 不同数据

![](C:\Users\Outlier\Desktop\Code\Homework-scnu\quick_sort\output.png)

从**随机分布无序序列**的结果来看，朴素快排性能小优于随机快排和三路快排，而numpy的排序算法则遥遥领先，原因是显然的，随机快排和三路快排都需要额外的资源来获取随机数和进行额外的取模操作。随机分布无序序列不同长度其实有不同的稀疏性，一开始长度较小时，序列中的值是稀疏的，但随着序列长度增加，会越来越有可能出现之前出现过的值，从而使得序列的值开始密集，这也有利于三路快排，但实际表现中，三路快排却略逊于随机快排，这个结果可能的解释是，稀疏性的变化带来的益处仍未超过三路快排中多次交换的消耗。

从**递增有序序列**的结果来看，朴素快速排序的结果是十分糟糕的，当然这也是精心设计的数据导致的，其性能退化到$O(n^2)$，而采用随机的随机快排和三路快排很好的避免了最坏的情况。与随机分布无序序列类似，随机快排略优于三路快排，其有更少的交换次数。

从**正态分布无序序列**的结果来看，最令人出乎意料的是三路快速排序获得最好的结果，这是因为此时数组内存在大量的重复的相等值，且中间值有更大的可能被选取为基准值，这进一步提高了三路快排的排序速度，而此时朴素快排略优于随机快排。

#### 同一方法

![output1](C:\Users\Outlier\Desktop\Code\Homework-scnu\quick_sort\output1.png)

从**朴素快排**在3个不同类型序列的表现来看，其在有序序列中的表现非常糟糕，故本实验并未完整测试该方法在有序序列中的完整性能，只测试到$10^7$ 长度的序列，且其在正态分布序列中的性能优于随机分布的性能，原因在于其每次选取基准值都有更大的可能选取到中间值，故更接近理论理论最优情况而获得更好的性能表现。

从**随机快排**在3个不同类型序列的表现来看，其在有序序列中的表现居然优于随机分布的无序序列，序列相对有序，由于选取的基准值随机选择，在避免了朴素快排的最差情况的同时，减少了每次划分时的交换次数，从而减少了排序的时间。

从**三路快排**在3个不同类型序列的表现来看，其对序列中相同数值的个数十分敏感，因此在有大量相同数值的正态分布序列中，其不但有更大概率选取数量更多中间值获得更好的划分，还进一步减少了下一轮排序的序列，从而获得最好的性能。对于有序序列和随机分布无序序列的性能差距与随机快排类似。

**numpy排序**也是基于快排实现的，但是其对不同情况都进行了优化，所以取得了大部分情况下的最好性能，但其对于正态分布序列的排序性能不如三路快排。

## 结论



## 参考文献

- [1] [Wikipedia](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)
- [2] [OI Wiki ](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)
- [3] [常用算法模板 ](https://www.acwing.com/blog/content/277/)
- [4] [GPT 3.4 ](https://chat.openai.com/)
- [5] [ctypes ](https://docs.python.org/3/library/ctypes.html)